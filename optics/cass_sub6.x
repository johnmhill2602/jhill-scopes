# cass_sub6.x
# generates raytrace input file (lens) for CODEV raytrace program

# 07NOV94 - created by J. M. Hill, Steward Observatory from cass_sub4.x
# At this point the functionality is limited relative to OSLO.

procedure codev_rays (rayfile, title)

include "cass_common.h"

# To Do:

# Parameter Variables
char	rayfile[ARB]	# name of the raytrace input file
char	title[ARB]	# name of the telescope

# Local Variables
string  version   "16-NOV-94"

int	xfd		# file descriptor

int     isurf           # surface counter
# keeps track of number of tracing surfaces

int     iref            # reflection counter
# toggles to keep track of sign convention on distances at mirrors
# also serves to convert meters to millimeters

double  netang, netcng          # net coordinate rotation for tilts
# variable to keep track of the previous rotations at fold mirrors

# Command format strings for CODEV
string  srefl_codev     "S     %14.6f %14.6f REFL\n"  # Reflecting Surface
string  sair_codev      "S     %14.6f %14.6f\n"       # Air Surface
string  simg_codev      "SI    %14.6f %14.6f\n"       # Image Surface
string  sobj_codev      "SO    %14.6f %14.6f\n"       # Object Surface
string  thc_codev       "  THC 0\n"
string  sto_codev       "  STO\n"                     # Aperture Stop
string  con_codev       "  CON;  K %14.8f\n"          # Conic
string  ccy_codev       "  CCY 0\n"
string  cirobs_codev    "  CIR OBS  %14.8f\n"         # Central Obstruction
string  ciredg_codev    "  CIR EDG  %14.8f\n"         # Edge Obstruction
string  ade_codev       "  ADE  %14.8f\n"
string  bde_codev       "  BDE  %14.8f\n"
string  cde_codev       "  CDE  %14.8f\n"
string  xde_codev       "  XDE  %14.8f\n"
string  yde_codev       "  YDE  %14.8f\n"
string  zde_codev       "  ZDE  %14.8f\n"

errchk	open, putline, close, salloc

# Functions
int	open()
int	strlen()
int     access()

begin

# Introduction
   call printf ("Writing CODEV format input file: %s\n")
       call pargstr(rayfile)
   call flush (STDOUT)

# Check for null filename
   if (strlen (rayfile) <= 0 ) {
      call printf ("No filename specified.\n")
		# Make this an error call later.
      call flush (STDOUT)
   }

# Does the file already exist?  For now delete it.
   if (access (rayfile, WRITE_ONLY, TEXT_FILE) == YES) {
      call printf ("Deleting existing output file.\n")
      call flush (STDOUT)
      call delete (rayfile)
   }

# Open new lens file
   xfd = open (rayfile, NEW_FILE, TEXT_FILE)

# Lens Info
   call fprintf ( xfd, "RDM; LEN\n" )
   call fprintf ( xfd, "TITLE ""%s""\n" )
       call pargstr (title)

   call fprintf ( xfd, "!Generated by SCOPES.OPTICS.CASS version %s.\n")
       call pargstr (version)  # version of this subroutine
   call fprintf ( xfd, "!    written by J. M. Hill, Steward Observatory.\n")

# Specify Entrance Pupil or Image Focal Ratio
   if ( irm2 ) {
      call fprintf ( xfd, "FNO   %12f\n")
          call pargd ( fsi ) # undersized pupil F/#
   }
   else {
      call fprintf ( xfd, "EPD   %12f\n")
          call pargd ( d1 * 1000.0d0 )  # primary diameter
   }

   call fprintf ( xfd, "DIM   M\n")     # dimensions in mm
   call fprintf ( xfd, "WL    500.0\n") # 500 nm
   call fprintf ( xfd, "REF   1\n")
   call fprintf ( xfd, "WTW   1\n")
   call fprintf ( xfd, "INI   ""CASS""\n")


.help   
   call fprintf ( xfd, oby_oslo ) # object height, sets angle on sky
       call pargd ( - tan( ubar1 ) * 1.0d20 )
.endhelp

   call fprintf ( xfd, "XAN   0.0 0.0 0.0\nYAN   0.0 %14.6f %14.6f\n")
       call pargd ( field / 240.0 )  # half field radius, degrees
       call pargd ( field / 120.0 )  # full field radius, degrees
   call fprintf ( xfd, "VUX   0.0 0.0 0.0\nVLX   0.0 0.0 0.0\n")
   call fprintf ( xfd, "VUY   0.0 0.0 0.0\nVLY   0.0 0.0 0.0\n")

# Specify Object Surface
   isurf = 1
   if ( rayrl ) { # flag for which way the telescope points (sign convention)
      iref = -1000 # Yes, rays enter from the right
      call fprintf ( xfd, sobj_codev )
          call pargr ( 0.0 )
          call pargr ( -1.0e20 ) # value?
   }
   else {
      iref = 1000  # No, rays enter from the left
      call fprintf ( xfd, sobj_codev )
          call pargr ( 0.0 )
          call pargr ( 1.0e20 ) # value?
   }
   
   netang = 2.0d0 * PI2  # starting at 180 deg is important for sign convention
   netcng = 0.0d0

# Entrance Pupil ahead of primary
   if ( irm2 && raypup ) {
      call fprintf ( xfd, "! Entrance Pupil\n" )
      isurf = isurf + 1
      iref = - iref
      call fprintf ( xfd, sair_codev)
          call pargd ( 0.0d0 )
          call pargd ( iref * spupil ) # distance to secondary
   } # end if irm2 for entrance pupil
   
# Primary Mirror
   call fprintf ( xfd, "! Primary Mirror\n" )
   isurf = isurf + 1
   iref = - iref
   call fprintf ( xfd, srefl_codev)
       call pargd ( iref * l1 * 2.0d0 )
   if ( rnum >= 2 ) {
#      if ( !irm2 )
	 call pargd ( iref * sep ) # distance to secondary
#      else
#	 call pargd ( iref * (sep-sag2) ) # distance to secondary edge
   }
   else {
          call pargd ( iref * l1 ) # distance to prime focus
   } 
   call fprintf ( xfd, thc_codev )
   if ( !irm2 )
      call fprintf ( xfd, sto_codev )        # aperture stop
   call fprintf ( xfd, con_codev )        # conic
       call pargd ( alpha1 )
   if ( rayobs ) {
      call fprintf ( xfd, cirobs_codev )     # central hole
          call pargd ( pbaffle * 500.0 )
      call fprintf ( xfd, ciredg_codev )     # edge of primary
          call pargd ( d1 * 500.0d0 )
   }

   if (rnum >= 2) {  # Is there a secondary mirror?
#      if ( irm2 ) {
#	 call fprintf ( xfd, "! Edge of Secondary\n" )
#	 isurf = isurf + 1
#	 call fprintf ( xfd, sair_codev)
#	     call pargd ( 0.0d0 )
#	     call pargd ( iref * sag2 )
#      }
      
# Secondary Mirror
      call fprintf ( xfd, "! Secondary Mirror\n" )
      isurf = isurf + 1
      iref = - iref
      call fprintf ( xfd, srefl_codev)
          call pargd ( iref * l2 * 2.0d0)
      if ( raypup && !irm2 )               # distance to pupil
	 call pargd ( iref * ( spupil ) )
#      else if ( irm2 )                    # distance to secondary edge
#	 call pargd ( iref * sag2 )
      else                                 # Don't put in exit pupil surface
	 call pargd ( iref * ( bfd - tfd ) )  # distance to tertiary

      call fprintf ( xfd, thc_codev )
      if ( irm2 ) 
	 call fprintf ( xfd, sto_codev )        # aperture stop
      call fprintf ( xfd, con_codev )
          call pargd (alpha2)
      if ( rayobs || irm2 ) {
	 call fprintf ( xfd, ciredg_codev )
             call pargd ( d2e * 500.0d0 )
      }

#      if ( irm2 ) {
#	 call fprintf ( xfd, "! Edge of Secondary\n" )
#	 isurf = isurf + 1
#	 call fprintf ( xfd, sair_codev)
#	     call pargd ( 0.0d0 )
#	     call pargd ( iref * ( bfd - tfd - sag2 ) )
#      }

      if ( raypup && !irm2 ) {
# Surface --- Exit Pupil
	 # This pupil is at the image of the primary vertex.
	 isurf = isurf + 1
	 call fprintf ( xfd, srefl_codev)
	     call pargd ( iref * l2 * 2.0d0 )  # This is a bogus curvature.
	     call pargd ( iref * ( bfd - tfd - spupil ) )
	 call fprintf ( xfd, ciredg_codev )
	     call pargd ( dpupil * 500.0d0 )
	 call fprintf ( xfd, con_codev )
	     call pargd ( -1.0d0 )
	 call fprintf ( xfd, "! Exit Pupil\n" )
      } # end of exit pupil surface

   } # end of secondary mirror

   if (rnum >= 3) {  # Is there a tertiary mirror?
# Surface 5 --- Tertiary
# Fold mirrors need a tilt surface at and behind the reflection.
# These both rotate in the same direction by the tilt of the mirror relative
#  to the oncoming ray.
# Rotation angle has 180 degree ambiguity --- is this whole routine mirrorred?
#  Except for preserving the curvature/thickness sign convention.
      
      isurf = isurf + 1
      iref = - iref
      call fprintf ( xfd, "! Tertiary\n" )
      call fprintf ( xfd, srefl_codev)  # flat
          call pargd ( 0.0d0 )
      if ( rnum == 3 )
             call pargd ( iref * tfd ) # tertiary to focal plane
      else if ( rnum == 5 && fs != 0.0d0 )
             call pargd ( iref * tfd ) # tertiary to first focal plane
      else if ( rnum == 5 && fs == 0.0d0 )
             call pargd ( iref * ffa ) # tertiary to fold flat
      else
             call pargd ( iref * ( tfd - bcfd ) ) # tertiary to beam combiner

#      call fprintf ( xfd, ap_oslo )  # major axis diameter
#          call pargd ( d3maj * 500.0d0 )
      call fprintf ( xfd, ade_codev ) # tilt around x-axis
          call pargd ( ( netang + at ) * DEG_RAD )
      if ( rayud ) { # bend light up from tertiary
	 call fprintf ( xfd, cde_codev ) # tilt around z-axis
             call pargd ( ( netcng + az ) * DEG_RAD - 180.0 )
      }
      else { # bend light down from teritary
	 call fprintf ( xfd, cde_codev ) # tilt around z-axis
            call pargd ( ( netcng + az  ) * DEG_RAD )
      }
      netcng = netcng + az
#      call fprintf ( xfd, tla_codev ) # tilt around x-axis
#          call pargd ( ( netang + at ) * DEG_RAD )
      netang = netang + iref * at / 500.0d0

   } # end if tertiary

.help
   if (rnum == 4) {  # Is there a beam combiner mirror?
# Fold mirrors need a tilt surface at and behind the reflection.
# These both rotate in the same direction by the tilt of the mirror relative
#  to the oncoming ray.
# After the first fold, you must subtract off the total previous tilts
#  in order to use the mirror angle from global coordinates.
# Surface --- Beam Combiner
      isurf = isurf + 1
      iref = - iref
      call fprintf ( xfd, cv0_oslo)
      call fprintf ( xfd, tla_oslo ) # tilt around x-axis
           call pargd ( ( netang + abp ) * DEG_RAD )
      call fprintf ( xfd, "! Beam Combiner\n" )
# Surface --- Beam Combiner
      isurf = isurf + 1
      call fprintf ( xfd, th_oslo )
       call pargd ( iref * bcfd )
      call fprintf ( xfd, tla_oslo ) # tilt around x-axis
           call pargd ( ( netang + abp ) * DEG_RAD )
      netang = netang + 2.0d0 * abp
      call fprintf ( xfd, "! Beam Combiner Tilt\n" )

# Surface --- Focal Plane Tilt
      isurf = isurf + 1
      call fprintf ( xfd, tla_oslo ) # tilt around x-axis
          call pargd ( ( aa ) * DEG_RAD )
      call fprintf ( xfd, "! Focal Plane Tilt\n" )
   } # end if beam combiner
.endhelp

   if ( fs != 0.0d0 ) { # first focal plane if not afocal
# Surface --- Focal Plane
      isurf = isurf + 1
      call fprintf ( xfd, "! Curved Focal Plane\n" )
      call fprintf ( xfd, simg_codev )
          call pargd ( - iref * fproc )    # differs from iref sign convention
          call pargr ( 0.0 )
#      call fprintf ( xfd, ape_codev )
#          call pargd ( fpdia * 500.0d0 )
      call fprintf ( xfd, con_codev )
          call pargd ( -1.0d0 )

# Doesn't account for further reimaging optics yet.
   } # end if first focal plane

.help
   if (rnum == 5 && fs != 0.0d0 ) {  # Is there a reimaging beam combiner?
# Surface --- Distance from First Focus to Fold Flat
      isurf = isurf + 1
      call fprintf ( xfd, th_oslo )
          call pargd ( iref * ffa )
# Surface --- Fold Flat, M4
      isurf = isurf + 1
      iref = - iref
      call fprintf ( xfd, cv0_oslo)
      call fprintf ( xfd, tla_oslo ) # tilt around x-axis
          call pargd ( ( netang + af ) * DEG_RAD )
      call fprintf ( xfd, "! Fold Flat\n" )
# Surface --- Distance from Fold Flat to Beam Combiner
      isurf = isurf + 1
      call fprintf ( xfd, th_oslo )
          call pargd ( iref * (ffb - ffa) )
      call fprintf ( xfd, tla_oslo ) # tilt around x-axis
          call pargd ( ( netang + af ) * DEG_RAD )
      netang = netang + 2.0d0 * af
# Surface --- Beam Combiner
      isurf = isurf + 1
       call fprintf ( xfd, tla_oslo ) # tilt around x-axis
           call pargd ( aeb * DEG_RAD )
      call fprintf ( xfd, "! Rotate Parallel\n" )
          call pargi ( iref )
# Surface
      isurf = isurf + 1
      call fprintf ( xfd, th_oslo )
          call pargd ( eoz * iref )
      call fprintf ( xfd, dcy_oslo )
          call pargd ( eox * iref )
          call pargd ( eoy * iref )         
      call fprintf ( xfd, "! Offset to Axis\n" )
# Surface
      isurf = isurf + 1
      iref = - iref
      call fprintf ( xfd, rd_oslo )
          call pargd ( iref * l5 * 2.0d0)
      call fprintf ( xfd, cc_oslo )
          call pargd (alpha5)
      # Set aperture for huge ellipse
      call fprintf ( xfd, ap_oslo )
          call pargd ( l5 * 500.0d0 )   # l5 * 2000.0d0 is maximum
      call fprintf ( xfd, "! Beam Combiner\n" )

# Surface
      isurf = isurf + 1
      call fprintf ( xfd, th_oslo )
          call pargd ( eoz * iref )
      call fprintf ( xfd, sdm_oslo )
           call pargi ( isurf - 2 )
      call fprintf ( xfd, "! Offset Return\n" )
# Surface
      isurf = isurf + 1
       call fprintf ( xfd, tla_oslo ) # tilt around x-axis
           call pargd ( - aea * DEG_RAD )
      call fprintf ( xfd, "! Rotate to Ray\n" )
      # netang  is now unknown in this program!
# Surface
      isurf = isurf + 1
      call fprintf ( xfd, th_oslo )
          call pargd ( iref * bcfd )
      call fprintf ( xfd, "! Translate\n" )

# Surface --- Focal Plane
      isurf = isurf + 1
      call fprintf ( xfd, rd_oslo )
          call pargd ( - iref * fproc )    # differs from iref sign convention
      call fprintf ( xfd, ap_oslo )
          call pargd ( fpdia * 500.0d0 )
      call fprintf ( xfd, cc_oslo )
          call pargd ( -1.0d0 )
      call fprintf ( xfd, "! Curved Focal Plane\n" )
          call pargi ( iref )
# Surface --- Focal Plane
      isurf = isurf + 1
      call fprintf ( xfd, pkcv_oslo )
          call pargi ( isurf - 1 )
      call fprintf ( xfd, pkap_oslo )
          call pargi ( isurf - 1 )

# Surface --- Focal Plane
      isurf = isurf + 1
      call fprintf ( xfd, cv0_oslo )
      call fprintf ( xfd, ap_oslo )
          call pargd ( fpdia * 500.0d0 )
      call fprintf ( xfd, "! Flat Focal Plane\n" )
      isurf = isurf + 1
      call fprintf ( xfd, pkcv_oslo )
          call pargi ( isurf - 1 )
      call fprintf ( xfd, pkap_oslo )
          call pargi ( isurf - 1 )

   } # end rnum=5

   else if (rnum == 5 && fs == 0.0d0 ) {  # Is there a afocal beam combiner?
# Surface --- Fold Flat, M4
      isurf = isurf + 1
      iref = - iref
      call fprintf ( xfd, cv0_oslo)
      call fprintf ( xfd, tla_oslo ) # tilt around x-axis
          call pargd ( ( netang + af ) * DEG_RAD )
      call fprintf ( xfd, "! Fold Flat\n" )
# Surface --- Distance from Fold Flat to Beam Combiner
      isurf = isurf + 1
      call fprintf ( xfd, th_oslo )
          call pargd ( iref * ffb )
      call fprintf ( xfd, tla_oslo ) # tilt around x-axis
          call pargd ( ( netang + af ) * DEG_RAD )
      netang = netang + 2.0d0 * af

# Surface --- Beam Combiner
      isurf = isurf + 1
      call fprintf ( xfd, dcy_oslo )
          call pargd ( yf * iref )
          call pargd ( xf * iref )  # doesn't account for lateral offset      
      call fprintf ( xfd, "! Offset to Axis\n" )
          call pargi ( iref )
# Surface
      isurf = isurf + 1
      iref = - iref
      call fprintf ( xfd, rd_oslo )
          call pargd ( iref * l5 * 2.0d0)
      call fprintf ( xfd, cc_oslo )
          call pargd (alpha5)
      call fprintf ( xfd, ap_oslo )
          call pargd ( d5 * 500.0d0 ) # aperture
      call fprintf ( xfd, "! Beam Combiner\n" )
          call pargi ( iref )
# Surface
      isurf = isurf + 1
      call fprintf ( xfd, sdm_oslo )
           call pargi ( isurf - 2 )
      call fprintf ( xfd, "! Offset Return\n" )
# Surface
      isurf = isurf + 1
       call fprintf ( xfd, tla_oslo ) # tilt around x-axis
           call pargd ( - aap * DEG_RAD )
      call fprintf ( xfd, "! Rotate to Ray\n" )
      # netang  is now unknown in this program!
# Surface
      isurf = isurf + 1
      call fprintf ( xfd, th_oslo )
          call pargd ( iref * bcfd )
      call fprintf ( xfd, "! Translate\n" )

# Surface --- Focal Plane
      isurf = isurf + 1
      call fprintf ( xfd, cv0_oslo )
      call fprintf ( xfd, ap_oslo )
          call pargd ( fpdia * 500.0d0 )
      call fprintf ( xfd, "! Flat Focal Plane\n" )
      isurf = isurf + 1
      call fprintf ( xfd, pkcv_oslo )
          call pargi ( isurf - 1 )
      call fprintf ( xfd, pkap_oslo )
          call pargi ( isurf - 1 )
   } # end else afocal
.endhelp
   
# End of the telescope
   call fprintf ( xfd, "GO\n")

# Close the projected file
	call close ( xfd )

end
