# cass_sub8.x
# generates raytrace input file (lens) for OSLOPRO raytrace program

# 30OCT96 - created by J. M. Hill, Steward Observatory from oslo_rays.

procedure oslopro_rays (rayfile, title, time)

include "cass_common.h"

# To Do:
#     Add out of plane tilts for beam combiners
#     Work on branches for newtonian secondary

# Parameter Variables
char	rayfile[ARB]	# name of the raytrace input file
char	title[ARB]	# name of the telescope
char	time[ARB]	# execution time

# Local Variables
string  version   "02-NOV-96"

int	xfd		# file descriptor

int     isurf           # surface counter
# keeps track of number of tracing surfaces

int     iref            # reflection counter
# toggles to keep track of sign convention on distances at mirrors
# also serves to convert meters to millimeters

double  netang, netcng          # net coordinate rotation for tilts
# variable to keep track of the previous rotations at fold mirrors

# Command format strings for OSLOPRO
string  ast_pro        "AST\n"
string  nxt_pro        "NXT  /* Surface %u */\n"
string  air_pro        "AIR\n"
string  rfl_pro        "RFH\n"    # Hatchable, else use RFL
string  bk7_pro        "GLA BK7\n"
string  th_pro         "TH  %14.6f\n"
string  tla_pro        "DT -1\nTLA %14.6f\n"
string  tlc_pro        "TLC %14.6f\n"
string  cv0_pro        "CV  0.000\n"
string  rd_pro         "RD  %14.6f\n"
string  ap_pro         "AP  %14.6f\n"
string  cc_pro         "CC  %14.8f  /* Conic */\n"
string  apn_pro        "APN    %u  /* Special Apertures */\n"
string  obta_pro     "ATP A  1  /* Ellipse */\nAAC A  2  /* Obstruct */\n"
string  obtb_pro     "ATP B  1  /* Ellipse */\nAAC B  2  /* Obstruct */\n"
string  apta_pro     "ATP A  1  /* Ellipse */\nAAC A  4  /* Transmit */\n"
string  aptb_pro     "ATP B  1  /* Ellipse */\nAAC B  4  /* Transmit */\n"
string  axya_pro     "AY1 A %14.6f\nAY2 A %14.6f\nAX1 A %14.6f\nAX2 A %14.6f\n"
string  axyb_pro     "AY1 B %14.6f\nAY2 B %14.6f\nAX1 B %14.6f\nAX2 B %14.6f\n"
string  pkcv_pro       "PK  CV  %u 0\n"
string  pkap_pro       "PK  AP  %u\n"
string  pkth_pro       "PK  TH  %u 0\n"
string  pkthm_pro      "PK  THM  %u 0\n"
string  dcy_pro        "SDT\nDT 1\nDCX %14.6f\nDCY %14.6f\n"
string  sdm_pro        "PK SDM %u\n"
string  not_pro        "NOT ""%s %5d""\n"
string  sno_pro        "SNO%u ""%s""\n"
string  sno2_pro        "SNO%u ""%s %s""\n"

string  shortit  "                                " # for the LEN command

errchk	open, putline, close, salloc

# Functions
int	open()
int	strlen()
int     access()

begin

# Introduction
   call printf ("Writing OSLO format input file: %s\n")
       call pargstr(rayfile)
   call flush (STDOUT)

# Check for null filename
   if (strlen (rayfile) <= 0 ) {
      call printf ("No filename specified.\n")
		# Make this an error call later.
      call flush (STDOUT)
   }

# Does the file already exist?  For now delete it.
   if (access (rayfile, WRITE_ONLY, TEXT_FILE) == YES) {
      call printf ("Deleting existing output file.\n")
      call flush (STDOUT)
      call delete (rayfile)
   }

# Open new lens file
   xfd = open (rayfile, NEW_FILE, TEXT_FILE)

# Lens Info
   call fprintf ( xfd, "// OSLO 5.10 0 0 0\n")  # Banner
       call pargstr (title)

   call strcpy ( title, shortit, 32 )
   call fprintf ( xfd, "LEN NEW ""%32s"" %12f %u\n")  # LEN must be first command
       call pargstr (shortit)
       call pargd ( ls * 1000.0d0 ) # focal length
       call pargl ( 0 ) # number of surfaces TBD

   call fprintf ( xfd, "DES ""CASS""\n")
   call fprintf ( xfd, "UNI  1\n")

   call fprintf ( xfd, sno_pro )
       call pargl (1)
       call pargstr (title)
   
   call fprintf ( xfd, sno2_pro )
       call pargl (2)
       call pargstr ("Generated by SCOPES.OPTICS.CASS version ")
       call pargstr (version)  # version of this subroutine

   call fprintf ( xfd, sno_pro )
       call pargl (3)
       call pargstr ("Written by J. M. Hill, Steward Observatory")

   call fprintf ( xfd, sno2_pro )
       call pargl (4)
       call pargstr ("Executed on: ")
       call pargstr (time)

   call fprintf ( xfd, air_pro )

   if ( irm2 ) {
      call fprintf ( xfd, "EBR %12f\n")
          call pargd ( d1i * 500.0d0 ) # undersized pupil (approximation?)
   }
   else {
      call fprintf ( xfd, "EBR %12f\n")
          call pargd ( d1 * 500.0d0 )  # primary diameter
   }
      
   if ( rayrl ) { # is the sign of infinity important? Maybe not.
      call fprintf ( xfd, th_pro  )
          call pargd ( -1.0d20 )
   }
   else {
      call fprintf ( xfd, th_pro  )
          call pargd (  1.0d20 )
   }
   
   call fprintf ( xfd, "OBH %18g  /* Object Height */\n"  ) # sets angle on sky
       call pargd ( - tan( ubar1 ) * 1.0d20 )
      
   isurf = 0
   
   if ( rayrl ) # flag for which way the telescope points (sign convention)
      iref = -1000 # Yes, rays enter from the right
   else
      iref = 1000  # No, rays enter from the left
   
   netang = 2.0d0 * PI2  # starting at 180 deg is important for sign convention
   netcng = 0.0d0
   

   if (rnum >= 2 && rayobs) {  # Is there a secondary mirror obstruction?
# Surface 3 --- secondary obstruction
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro )
      call fprintf ( xfd, th_pro )
          call pargd ( - iref * (sep - sag2) )
      # thickness differs from iref sign convention because next surface
      #     the obstruction, is moving back "up" the incoming rays.
      call fprintf ( xfd, rd_pro  )
          call pargd ( - iref * l1 * 2.0d0 )
      # sign of radius differs from iref sign convention
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Dummy Obstruction" )
          call pargi ( iref )
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
      call fprintf ( xfd, pkthm_pro  )
          call pargi ( isurf - 1 )
      call fprintf ( xfd, apn_pro  )
          call pargl (1)
      call fprintf ( xfd, obta_pro  )
      call fprintf ( xfd, axya_pro  )
          call pargd ( - d2v * 500.0d0 )
          call pargd ( d2v * 500.0d0 )
          call pargd (- d2v * 500.0d0 )
          call pargd ( d2v * 500.0d0 )
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Obstruction" )
          call pargi ( iref )
   } # end of secondary obstruction

# Surface 4 --- Primary Mirror
   isurf = isurf + 1
   iref = - iref
   call fprintf ( xfd, nxt_pro  )
       call pargi ( isurf )
   call fprintf ( xfd, ast_pro  )        # aperture stop
   call fprintf ( xfd, rfl_pro )
   if ( rnum >= 2 ) {
      call fprintf ( xfd, th_pro  )
          call pargd ( iref * sep ) # distance to secondary
   }
   else {
      call fprintf ( xfd, th_pro  )
          call pargd ( iref * l1 ) # distance to prime focus
   }
   call fprintf ( xfd, rd_pro  )
       call pargd ( iref * l1 * 2.0d0 )
   call fprintf ( xfd, cc_pro  )
       call pargd (alpha1)
   if ( rayobs ) {
      call fprintf ( xfd, apn_pro  )
          call pargl (2)
      call fprintf ( xfd, apta_pro  )     # edge of primary
      call fprintf ( xfd, axya_pro  )
          call pargd ( - d1 * 500.0d0 )
          call pargd ( d1 * 500.0d0 )
          call pargd ( - d1 * 500.0d0 )
          call pargd ( d1 * 500.0d0 )
      call fprintf ( xfd, obtb_pro  )     # hole in primary
      call fprintf ( xfd, axyb_pro  )
          call pargd ( - d1h * 500.0d0 )
          call pargd ( d1h * 500.0d0 )
          call pargd ( - d1h * 500.0d0 )
          call pargd ( d1h * 500.0d0 )
   }
   call fprintf ( xfd, ap_pro  ) # redundant with SAP or entrance pupil?
       call pargd ( d1 * 500.0d0 )
   call fprintf ( xfd, not_pro  )
       call pargstr ( "Primary" )
       call pargi ( iref )

   if (rnum >= 2) {  # Is there a secondary mirror?
# Surface 4 --- Secondary Mirror
      isurf = isurf + 1
      iref = - iref
      call fprintf ( xfd, nxt_pro  )
       call pargi ( isurf )
      if ( irm2 ) {
	 call fprintf ( xfd, ast_pro  )        # aperture stop
	 call fprintf ( xfd, ap_pro  )
	     call pargd ( d2e * 500.0d0 )
      }
      call fprintf ( xfd, rfl_pro )
      if ( raypup && !irm2 ) {
	 call fprintf ( xfd, th_pro  )
	     call pargd ( iref * ( spupil ) )  # distance to pupil
      }
      else {  # Don't put in exit pupil surface
	 call fprintf ( xfd, th_pro  )
	     call pargd ( iref * ( bfd - tfd ) )  # distance to tertiary
      }
      call fprintf ( xfd, rd_pro  )
       call pargd ( iref * l2 * 2.0d0)
      call fprintf ( xfd, cc_pro  )
       call pargd (alpha2)
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Secondary" )
          call pargi ( iref )

      if ( raypup && !irm2 ) {
# Surface --- Exit Pupil
	 # This pupil is at the location of the image of the primary vertex.
	 isurf = isurf + 1
	 call fprintf ( xfd, nxt_pro  )
	     call pargi ( isurf )
	 call fprintf ( xfd, bk7_pro  )
	 call fprintf ( xfd, rd_pro  )
	     call pargd ( iref * l2 * 2.0d0 )  # This is a bogus curvature.
	 call fprintf ( xfd, ap_pro  )
	     call pargd ( dpupil * 500.0d0 )
	 call fprintf ( xfd, cc_pro  )
	     call pargd ( -1.0d0 )
	 call fprintf ( xfd, not_pro  )
	     call pargstr ( "Exit Pupil" )
	     call pargi ( iref )
# Surface --- Exit Pupil
	 isurf = isurf + 1
	 call fprintf ( xfd, nxt_pro  )
	     call pargi ( isurf )
	 call fprintf ( xfd, air_pro  )
	 call fprintf ( xfd, pkcv_pro  )
	     call pargi ( isurf - 1 )
	 call fprintf ( xfd, pkap_pro  )
	     call pargi ( isurf - 1 )
	 call fprintf ( xfd, th_pro  )
	     call pargd ( iref * ( bfd - tfd - spupil ) )
      } # end of exit pupil surface
   } # end of secondary mirror

   if (rnum >= 3) {  # Is there a tertiary mirror?
# Surface 5 --- Tertiary
# Fold mirrors need a tilt surface at and behind the reflection.
# These both rotate in the same direction by the tilt of the mirror relative
#  to the oncoming ray.
# Rotation angle has 180 degree ambiguity --- is this whole routine mirrorred?
#  Except for preserving the curvature/thickness sign convention.
      
      isurf = isurf + 1
      iref = - iref
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, rfl_pro )
      call fprintf ( xfd, cv0_pro )  # flat
      call fprintf ( xfd, ap_pro  )  # major axis diameter
          call pargd ( d3maj * 500.0d0 )
      call fprintf ( xfd, tla_pro  ) # tilt around x-axis
          call pargd ( ( netang + at ) * DEG_RAD )
      if ( rayud ) { # bend light up from tertiary
	 call fprintf ( xfd, tlc_pro  ) # tilt around z-axis
             call pargd ( ( netcng + az ) * DEG_RAD - 180.0 )
      }
      else { # bend light down from teritary
	 call fprintf ( xfd, tlc_pro  ) # tilt around z-axis
            call pargd ( ( netcng + az  ) * DEG_RAD )
      }
      netcng = netcng + az
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Tertiary" )
          call pargi ( iref )
# Surface 
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
      if ( rnum == 3 ) {
	 call fprintf ( xfd, th_pro  )
             call pargd ( iref * tfd ) # tertiary to focal plane
      }
      else if ( rnum == 5 && fs != 0.0d0 ) {
	 call fprintf ( xfd, th_pro  )
             call pargd ( iref * tfd ) # tertiary to first focal plane
      }
      else if ( rnum == 5 && fs == 0.0d0 ) {
	 call fprintf ( xfd, th_pro  )
             call pargd ( iref * ffa ) # tertiary to fold flat
      }
      else {
	 call fprintf ( xfd, th_pro  )
             call pargd ( iref * ( tfd - bcfd ) ) # tertiary to beam combiner
      }
      call fprintf ( xfd, tla_pro  ) # tilt around x-axis
          call pargd ( ( netang + at ) * DEG_RAD )
      netang = netang + iref * at / 500.0d0
   } # end if tertiary
   
   if (rnum == 4) {  # Is there a beam combiner mirror?
# Fold mirrors need a tilt surface at and behind the reflection.
# These both rotate in the same direction by the tilt of the mirror relative
#  to the oncoming ray.
# After the first fold, you must subtract off the total previous tilts
#  in order to use the mirror angle from global coordinates.
# Surface --- Beam Combiner
      isurf = isurf + 1
      iref = - iref
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, rfl_pro )
      call fprintf ( xfd, cv0_pro )
      call fprintf ( xfd, tla_pro  ) # tilt around x-axis
           call pargd ( ( netang + abp ) * DEG_RAD )
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Beam Combiner" )
          call pargi ( iref )
# Surface --- Beam Combiner
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
      call fprintf ( xfd, th_pro  )
       call pargd ( iref * bcfd )
      call fprintf ( xfd, tla_pro  ) # tilt around x-axis
           call pargd ( ( netang + abp ) * DEG_RAD )
      netang = netang + 2.0d0 * abp
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Beam Combiner Tilt" )
          call pargi ( iref )

# Surface --- Focal Plane Tilt
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
      call fprintf ( xfd, tla_pro  ) # tilt around x-axis
#          call pargd ( ( netang + aa ) * DEG_RAD )
          call pargd ( ( aa ) * DEG_RAD )
#      netang = netang + aa
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Focal Plane Tilt" )
          call pargi ( iref )
   } # end if beam combiner

   if ( fs != 0.0d0 ) { # first focal plane if not afocal
# Surface --- Focal Plane
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, bk7_pro  )
      call fprintf ( xfd, rd_pro  )
          call pargd ( - iref * fproc )    # differs from iref sign convention
      call fprintf ( xfd, ap_pro  )
          call pargd ( fpdia * 500.0d0 )
      call fprintf ( xfd, cc_pro  )
          call pargd ( -1.0d0 )
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Curved Focal Plane" )
          call pargi ( iref )
# Surface --- Focal Plane
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
      call fprintf ( xfd, pkcv_pro  )
          call pargi ( isurf - 1 )
      call fprintf ( xfd, pkap_pro  )
          call pargi ( isurf - 1 )

# Surface --- Focal Plane
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, bk7_pro  )
      call fprintf ( xfd, cv0_pro  )
      call fprintf ( xfd, ap_pro  )
          call pargd ( fpdia * 500.0d0 )
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Flat Focal Plane" )
          call pargi ( iref )
# Surface --- Focal Plane
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
      call fprintf ( xfd, pkcv_pro  )
          call pargi ( isurf - 1 )
      call fprintf ( xfd, pkap_pro  )
          call pargi ( isurf - 1 )
   } # end if first focal plane

   if (rnum == 5 && fs != 0.0d0 ) {  # Is there a reimaging beam combiner?
# Surface --- Distance from First Focus to Fold Flat
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
      call fprintf ( xfd, th_pro  )
          call pargd ( iref * ffa )
# Surface --- Fold Flat, M4
      isurf = isurf + 1
      iref = - iref
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, rfl_pro )
      call fprintf ( xfd, cv0_pro )
      call fprintf ( xfd, tla_pro  ) # tilt around x-axis
          call pargd ( ( netang + af ) * DEG_RAD )
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Fold Flat" )
          call pargi ( iref )
# Surface --- Distance from Fold Flat to Beam Combiner
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
      call fprintf ( xfd, th_pro  )
          call pargd ( iref * (ffb - ffa) )
      call fprintf ( xfd, tla_pro  ) # tilt around x-axis
          call pargd ( ( netang + af ) * DEG_RAD )
      netang = netang + 2.0d0 * af
# Surface --- Beam Combiner
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
       call fprintf ( xfd, tla_pro  ) # tilt around x-axis
           call pargd ( aeb * DEG_RAD )
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Rotate Parallel" )
          call pargi ( iref )
# Surface
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
      call fprintf ( xfd, th_pro  )
          call pargd ( eoz * iref )
      call fprintf ( xfd, dcy_pro  )
          call pargd ( eox * iref )
          call pargd ( eoy * iref )         
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Offset to Axis" )
          call pargi ( iref )
# Surface
      isurf = isurf + 1
      iref = - iref
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, rfl_pro )
      call fprintf ( xfd, rd_pro  )
          call pargd ( iref * l5 * 2.0d0)
      call fprintf ( xfd, cc_pro  )
          call pargd (alpha5)
      # Set aperture for huge ellipse
      call fprintf ( xfd, ap_pro  )
          call pargd ( l5 * 500.0d0 )   # l5 * 2000.0d0 is maximum
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Beam Combiner" )
          call pargi ( iref )
# Surface
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
      call fprintf ( xfd, th_pro  )
          call pargd ( eoz * iref )
      call fprintf ( xfd, sdm_pro  )
           call pargi ( isurf - 2 )
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Offset Return" )
          call pargi ( iref )
# Surface
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
       call fprintf ( xfd, tla_pro  ) # tilt around x-axis
           call pargd ( - aea * DEG_RAD )
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Rotate to Ray" )
          call pargi ( iref )
      # netang  is now unknown in this program!
# Surface
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
      call fprintf ( xfd, th_pro  )
          call pargd ( iref * bcfd )
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Translate" )
          call pargi ( iref )

# Surface --- Focal Plane
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, bk7_pro  )
      call fprintf ( xfd, rd_pro  )
          call pargd ( - iref * fproc )    # differs from iref sign convention
      call fprintf ( xfd, ap_pro  )
          call pargd ( fpdia * 500.0d0 )
      call fprintf ( xfd, cc_pro  )
          call pargd ( -1.0d0 )
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Curved Focal Plane" )
          call pargi ( iref )
# Surface --- Focal Plane
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
      call fprintf ( xfd, pkcv_pro  )
          call pargi ( isurf - 1 )
      call fprintf ( xfd, pkap_pro  )
          call pargi ( isurf - 1 )

# Surface --- Focal Plane
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, bk7_pro  )
      call fprintf ( xfd, cv0_pro  )
      call fprintf ( xfd, ap_pro  )
          call pargd ( fpdia * 500.0d0 )
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Flat Focal Plane" )
          call pargi ( iref )
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
      call fprintf ( xfd, pkcv_pro  )
          call pargi ( isurf - 1 )
      call fprintf ( xfd, pkap_pro  )
          call pargi ( isurf - 1 )

   } # end rnum=5

   else if (rnum == 5 && fs == 0.0d0 ) {  # Is there a afocal beam combiner?
# Surface --- Fold Flat, M4
      isurf = isurf + 1
      iref = - iref
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, rfl_pro )
      call fprintf ( xfd, cv0_pro )
      call fprintf ( xfd, tla_pro  ) # tilt around x-axis
          call pargd ( ( netang + af ) * DEG_RAD )
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Fold Flat" )
          call pargi ( iref )
# Surface --- Distance from Fold Flat to Beam Combiner
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
      call fprintf ( xfd, th_pro  )
          call pargd ( iref * ffb )
      call fprintf ( xfd, tla_pro  ) # tilt around x-axis
          call pargd ( ( netang + af ) * DEG_RAD )
      netang = netang + 2.0d0 * af

# Surface --- Beam Combiner
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
      call fprintf ( xfd, dcy_pro  )
          call pargd ( yf * iref )
          call pargd ( xf * iref )  # doesn't account for lateral offset      
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Offset to Axis" )
          call pargi ( iref )
# Surface
      isurf = isurf + 1
      iref = - iref
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, rfl_pro )
      call fprintf ( xfd, rd_pro  )
          call pargd ( iref * l5 * 2.0d0)
      call fprintf ( xfd, cc_pro  )
          call pargd (alpha5)
      call fprintf ( xfd, ap_pro  )
          call pargd ( d5 * 500.0d0 ) # aperture
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Beam Combiner" )
          call pargi ( iref )
# Surface
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
      call fprintf ( xfd, sdm_pro  )
           call pargi ( isurf - 2 )
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Offset Return" )
          call pargi ( iref )
# Surface
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
       call fprintf ( xfd, tla_pro  ) # tilt around x-axis
           call pargd ( - aap * DEG_RAD )
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Rotate to Ray" )
          call pargi ( iref )
      # netang  is now unknown in this program!
# Surface
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
      call fprintf ( xfd, th_pro  )
          call pargd ( iref * bcfd )
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Translate" )
          call pargi ( iref )

# Surface --- Focal Plane
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, bk7_pro  )
      call fprintf ( xfd, cv0_pro  )
      call fprintf ( xfd, ap_pro  )
          call pargd ( fpdia * 500.0d0 )
      call fprintf ( xfd, not_pro  )
          call pargstr ( "Flat Focal Plane" )
          call pargi ( iref )
      isurf = isurf + 1
      call fprintf ( xfd, nxt_pro  )
          call pargi ( isurf )
      call fprintf ( xfd, air_pro  )
      call fprintf ( xfd, pkcv_pro  )
          call pargi ( isurf - 1 )
      call fprintf ( xfd, pkap_pro  )
          call pargi ( isurf - 1 )
   } # end else afocal
   
# End of the telescope
   call fprintf ( xfd, "END  %u\n")
       call pargi ( isurf )

# Close the projected file
	call close ( xfd )

end
